package cs1501_p5;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.List;

public class BucketingMapGenerator implements ColorMapGenerator_Inter{

    private Pixel intToPixel(int val) {
        int r = (val >> 16) & 0xFF;
        int g = (val >> 8) & 0xFF;
        int b = val & 0xFF;
        return new Pixel(r, g, b);
    }

    private int pixelToInt(Pixel p) {
        return ((p.getRed() & 0xFF) << 16)
            | ((p.getGreen() & 0xFF) << 8)
            | (p.getBlue() & 0xFF);
    }

    /**
     * Produces an initial palette. For bucketing implementations, the initial
     * palette will be the centers of the evenly-divided buckets. For clustering
     * implementations, the initial palette will be the initial centroids. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the 2D Pixel array that represents a bitmap image
     * @param numColors the number of desired colors in the palette
     * @return a Pixel array containing numColors elements
     */
    public Pixel[] generateColorPalette(Pixel[][] pixelArray, int numColors) {
        if (pixelArray == null || pixelArray.length == 0 || pixelArray[0].length == 0) {
            Pixel[] emptyPalette = new Pixel[numColors];
            for (int i = 0; i < numColors; i++) {
                emptyPalette[i] = new Pixel(0, 0, 0);
            }
            return emptyPalette;
        }
        if (numColors <= 0) {
            throw new IllegalArgumentException("Number of colors must be positive");
        }
        Pixel[] palette = new Pixel[numColors];
        int totalColors = 1 << 24;
        double sizeD = (double) totalColors / (double) numColors;

        for (int i = 0; i < numColors; i++) {
            double midDouble = (i + 0.5) * sizeD;
            int middleValue = (int) Math.floor(midDouble);
            if (middleValue >= totalColors) {
                middleValue = totalColors - 1;
            }
            palette[i] = intToPixel(middleValue);
        }
        return palette;
    }

    /**
     * Computes the reduced color map. For bucketing implementations, this will
     * map each color to the center of its bucket. For clustering
     * implementations, this will map each color to its final centroid. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the pixels array that represents a bitmap image
     * @param initialColorPalette an initial color palette, such as those
     * generated by generateColorPalette, represented as an array of Pixels
     * @return A Map that maps each distinct color in pixelArray to a final
     * color
     */
    public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[] initialColorPalette) {
        Map<Pixel, Pixel> colorMap = new HashMap<>();
        int totalColors = 1 << 24;
        int numColors = initialColorPalette.length;
        int bucketSize = totalColors / numColors;

        for (Pixel[] row : pixelArray) {
            for (Pixel original : row) {
                if (!colorMap.containsKey(original)) {
                    int colorVal = pixelToInt(original);
                    int bucketIndex = colorVal / bucketSize;
                    if (bucketIndex >= numColors) {
                        bucketIndex = numColors - 1;
                    }
                    colorMap.put(original, initialColorPalette[bucketIndex]);
                }
            }
        }
        return colorMap;
    }

}