package cs1501_p5;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.List;


public class ClusteringMapGenerator implements ColorMapGenerator_Inter{
    private DistanceMetric_Inter metric;
    private final int MAX_ITERATIONS = 50;

    public ClusteringMapGenerator(DistanceMetric_Inter metric) {
        this.metric = metric;
    }


    /**
     * Produces an initial palette. For bucketing implementations, the initial
     * palette will be the centers of the evenly-divided buckets. For clustering
     * implementations, the initial palette will be the initial centroids. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the 2D Pixel array that represents a bitmap image
     * @param numColors the number of desired colors in the palette
     * @return a Pixel array containing numColors elements
     */
    public Pixel[] generateColorPalette(Pixel[][] pixelArray, int numColors){
        if (pixelArray == null || pixelArray.length == 0 || pixelArray[0].length == 0) {
            Pixel[] emptyPalette = new Pixel[numColors];
            for (int i = 0; i < numColors; i++) {
                emptyPalette[i] = new Pixel(0, 0, 0);
            }
            return emptyPalette;
        }

        Set<Pixel> distinct = getDistinctColors(pixelArray);
        List<Pixel> distinctList = new ArrayList<>(distinct);

        Pixel[] center = new Pixel[numColors];

        center[0] = pixelArray[0][0];


        for (int i = 1; i < numColors; i++) {
            double bestDist = -1;
            Pixel bestColor = null;

            for (Pixel c : distinctList) {
                double distToClosest = Double.MAX_VALUE;
                for (int j = 0; j < i; j++) {
                    double d = metric.colorDistance(c, center[j]);
                    if (d < distToClosest) {
                        distToClosest = d;
                    }
                }

                if (distToClosest > bestDist) {
                    bestDist = distToClosest;
                    bestColor = c;
                } else if (Math.abs(distToClosest - bestDist) < 1e-9) {
                    if (pixelToInt(c) > pixelToInt(bestColor)) {
                        bestColor = c;
                    }
                }
            }

            center[i] = bestColor;
        }

        return center;
    }

    /**
     * Computes the reduced color map. For bucketing implementations, this will
     * map each color to the center of its bucket. For clustering
     * implementations, this will map each color to its final centroid. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the pixels array that represents a bitmap image
     * @param initialColorPalette an initial color palette, such as those
     * generated by generateColorPalette, represented as an array of Pixels
     * @return A Map that maps each distinct color in pixelArray to a final
     * color
     */
    public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[] initialColorPalette){
        // Gather distinct colors
        Set<Pixel> distinct = getDistinctColors(pixelArray);
        List<Pixel> distinctList = new ArrayList<>(distinct);

        // Copy the initial centroids
        Pixel[] center = new Pixel[initialColorPalette.length];
        for (int i = 0; i < initialColorPalette.length; i++) {
            center[i] = initialColorPalette[i];
        }

        // Repeatedly update centroid positions
        for (int iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
            // Create clusters for each centroid
            List<List<Pixel>> clusters = new ArrayList<>();
            for (int i = 0; i < center.length; i++) {
                clusters.add(new ArrayList<>());
            }

            // Assign each color to its nearest centroid
            for (Pixel color : distinctList) {
                int closestIndex = 0;
                double closestDist = metric.colorDistance(color, center[0]);

                for (int i = 1; i < center.length; i++) {
                    double d = metric.colorDistance(color, center[i]);
                    if (d < closestDist) {
                        closestDist = d;
                        closestIndex = i;
                    }
                }
                clusters.get(closestIndex).add(color);
            }

            // Compute new centroids by averaging each cluster
            boolean changed = false;
            for (int i = 0; i < clusters.size(); i++) {
                if (clusters.get(i).isEmpty()) {
                    // If no points in cluster, skip or keep old centroid
                    // (You could also choose a random color, etc.)
                    continue;
                }
                Pixel newCenter = averageColor(clusters.get(i));
                if (!newCenter.equals(center[i])) {
                    center[i] = newCenter;
                    changed = true;
                }
            }

            // If no centroid changed, we have converged
            if (!changed) {
                break;
            }
        }

        // Build final map from each distinct color to nearest centroid
        Map<Pixel, Pixel> colorMap = new HashMap<>();
        for (Pixel c : distinctList) {
            // find nearest final centroid
            Pixel bestCenter = center[0];
            double bestDist = metric.colorDistance(c, bestCenter);
            for (int i = 1; i < center.length; i++) {
                double d = metric.colorDistance(c, center[i]);
                if (d < bestDist) {
                    bestDist = d;
                    bestCenter = center[i];
                }
            }
            colorMap.put(c, bestCenter);
        }

        return colorMap;
    }

    private Pixel averageColor(List<Pixel> cluster) {
        long sumR = 0, sumG = 0, sumB = 0;
        for (Pixel p : cluster) {
            sumR += p.getRed();
            sumG += p.getGreen();
            sumB += p.getBlue();
        }
        double size = cluster.size();
        int avgR = (int) (sumR / size);
        int avgG = (int) (sumG / size);
        int avgB = (int) (sumB / size);
        return new Pixel(avgR, avgG, avgB);
    }

    /**
     * Helper to collect all distinct colors from the image.
     */
    private Set<Pixel> getDistinctColors(Pixel[][] pixelArray) {
        Set<Pixel> distinct = new HashSet<>();
        for (int x = 0; x < pixelArray.length; x++) {
            for (int y = 0; y < pixelArray[x].length; y++) {
                distinct.add(pixelArray[x][y]);
            }
        }
        return distinct;
    }
    private int pixelToInt(Pixel p) {
        return (p.getRed() << 16) | (p.getGreen() << 8) | p.getBlue();
    }
}
